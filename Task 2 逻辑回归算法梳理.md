# Task 2 逻辑回归算法梳理
##### 1、逻辑回归与线性回归的联系与区别
逻辑回归与线性回归都属于广义线性回归模型,其区别与联系从以下几个方面比较：

* **1.分类与回归**:回归模型就是预测一个连续变量(如降水量，价格等)。在分类问题中，预测属于某类的概率，可以看成回归问题。这可以说是使用回归算法的分类方法。
* **2.输出**:直接使用线性回归的输出作为概率是有问题的，因为其值有可能小于0或者大于1,这是不符合实际情况的，逻辑回归的输出正是[0,1]区间。见下图，

* **3.参数估计方法**：

线性回归中使用的是最小化平方误差损失函数，对偏离真实值越远的数据惩罚越严重。这样做会有什么问题呢？假如使用线性回归对{0,1}二分类问题做预测，则一个真值为1的样本，其预测值为50，那么将会对其产生很大的惩罚，这也和实际情况不符合，更大的预测值说明为1的可能性越大，而不应该惩罚的越严重。
逻辑回归使用对数似然函数进行参数估计，使用交叉熵作为损失函数，对预测错误的惩罚是随着输出的增大，逐渐逼近一个常数，这就不存在上述问题了1
也正是因为使用的参数估计的方法不同，线性回归模型更容易受到异常值(outlier)的影响，有可能需要不断变换阈值(threshold),线性回归分类的情况见下面两图:

* 无异常值的线性回归情况:![绿线为求得的h(x)，上图中可选阈值为0.5作为判断肿瘤是否是良性。](https://img-blog.csdnimg.cn/20190303191911558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODE1Mjk4,size_16,color_FFFFFF,t_70)


绿线为求得的h(x)，上图中可选阈值为0.5作为判断肿瘤是否是良性。
* 有异常值的线性回归情况:![在这里插入图片描述](https://img-blog.csdnimg.cn/20190303192248491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODE1Mjk4,size_16,color_FFFFFF,t_70)



这个时候再想有好的预测效果需调整阈值为0.2，才能准确预测。
* 使用逻辑回归的方法进行分类，就明显对异常值有较好的稳定性。如下图:![在这里插入图片描述](https://img-blog.csdnimg.cn/20190303192322196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODE1Mjk4,size_16,color_FFFFFF,t_70)

* **4.参数解释**: 
* 线性回归中，独立变量的系数解释十分明了，就是保持其他变量不变时，改变单个变量因变量的改变量。
* 逻辑回归中，自变量系数的解释就要视情况而定了，要看选用的概率分布是什么，如二项式分布，泊松分布等



##### 2、逻辑回归的原理
逻辑回归模型是一种分类模型，用条件概率分布的形式表示$P(Y|X)$，这里随机变量 X 取值为 n 维实数向量，例如$x=(x^{(1)},x^{(2)},...,x^{(n)})$，Y 取值为 0 或 1。即： 
$$P(Y=1|x)=\frac{exp(w⋅x+b)}{1+exp(w⋅x+b)}$$

$$P(Y=0|0)=\frac{1}{1+exp(w⋅x+b)}$$

或：

$$ϕ(x)=\frac{1}{1+e^{−w^Tx−b}}$$
假设有一个二分类问题，输出为y∈{0,1}，二线性回归模型$z=w^Tx+b$是个实数值，我们希望有一个理想的阶跃函数来帮我什么实现z值到0/1值的转化，于是找到了Sigmoid函数来代替： 
$$g(z)=\frac{1}{1+e^{−z}}$$


有了 Sigmoid 函数之后，由于其值取值范围在[0,1]。就可以将其视为类 1 的后验概率估计$ p(y=1|X)$。说白了，就是如果有了一个测试点 x，那么就可以用Sigmoid函数算出来的结果当作该点 x 属于类别 1 的概率大小。

于是，非常自然地，我们把 Sigmoid 函数计算得到的值大于等于0.5的归为类别1，小于0.5的归为类别0：

##### 3、逻辑回归损失函数推导及优化
[逻辑回归的推导过程,regfer:https://www.imooc.com/article/69668](https://www.imooc.com/article/69668)

###### 4、正则化与模型评估指标
（1） 过拟合问题 
过拟合即是过分拟合了训练数据，使得模型的复杂度提高，繁华能力较差（对未知数据的预测能力） 

（2）过拟合主要原因 
过拟合问题往往源自过多的特征 
解决方法 
1）减少特征数量（减少特征会失去一些信息，即使特征选的很好） 
• 可用人工选择要保留的特征； 
• 模型选择算法； 
2）正则化（特征较多时比较有效） 
• 保留所有特征，但减少θ的大小

（3）正则化方法 
正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项或惩罚项。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化项就越大。

正则项可以取不同的形式，在回归问题中取平方损失，就是参数的L2范数，也可以取L1范数。取平方损失时，模型的损失函数变为：

$$J(θ) = l(θ) + 1/m * ∑ θ2 $$

lambda是正则项系数： 
• 如果它的值很大，说明对模型的复杂度惩罚大，对拟合数据的损失惩罚小，这样它就不会过分拟合数据，在训练数据上的偏差较大，在未知数据上的方差较小，但是可能出现欠拟合的现象； 
• 如果它的值很小，说明比较注重对训练数据的拟合，在训练数据上的偏差会小，但是可能会导致过拟合。 
正则化后的梯度下降算法θ的更新变为：

$$θ = θ - λ/m *∑ (h(x)-y)*x - λ/m * θ$$

###### 5、逻辑回归的优缺点
优点：

1）预测结果是界于0和1之间的概率；

2）可以适用于连续性和类别性自变量；

3）容易使用和解释；



缺点：

1）对模型中自变量多重共线性较为敏感，例如两个高度相关自变量同时放入模型，可能导致较弱的一个自变量回归符号不符合预期，符号被扭转。​需要利用因子分析或者变量聚类分析等手段来选择代表性的自变量，以减少候选变量之间的相关性；

2）预测结果呈“S”型，因此从log(odds)向概率转化的过程是非线性的，在两端随着​log(odds)值的变化，概率变化很小，边际值太小，slope太小，而中间概率的变化很大，很敏感。 导致很多区间的变量变化对目标概率的影响没有区分度，无法确定阀值。

###### 6、样本不均衡问题解决办法
解决样本不均衡的问题很多，主流的几个如下：

1.样本的过采样和欠采样。

2..使用多个分类器进行分类。

3.将二分类问题转换成其他问题。

4.改变正负类别样本在模型中的权重。

 

 

一、样本的过采样和欠采样。

1.过采样：将稀有类别的样本进行复制，通过增加此稀有类样本的数量来平衡数据集。该方法适用于数据量较小的情况。

2.欠抽样：从丰富类别的样本中随机选取和稀有类别相同数目的样本，通过减少丰富类的样本量啦平衡数据集。该方法适用于数据量较大的情况。

3.也可以将过采样和欠采样结合在一起使用。

4.使用SMOTE方法来构造样本。

　　SMOTE算法是一种过采样的算法。这个算法不是简单的复制已有的数据，而是在原有数据基础上，通过算法产生新生数据。

　　算法思想：基于距离度量的方式计算两个或多个稀有类样本之间的相似性。

　　　　　　　然后选择其中的一个样本作为基础样本，

　　　　　　　再在邻居样本中随机选取一定数量的样本对那个基础样本的一个属性进行噪声。每次处理一个属性，通过这样的方式产生新生数据。

二、使用多个分类器进行分类。

　　方法一中介绍的过采样，欠采样，都存在相应的问题。

　　过采样：可能会存在过拟合问题。（可以使用SMOTE算法，增加随机的噪声的方式来改善这个问题）

　　欠采样：可能会存在信息减少的问题。因为只是利用了一部分数据，所以模型只是学习到了一部分模型。

　　有以下两种方法可以解决欠采样所带来的问题。

　　方法一：模型融合 （bagging的思想 ）

　　思路：从丰富类样本中随机的选取（有放回的选取）和稀有类等量样本的数据。和稀有类样本组合成新的训练集。这样我们就产生了多个训练集，并且是互相独立的，然后训练得到多个分类器。

　　　　　若是分类问题，就把多个分类器投票的结果（少数服从多数）作为分类结果。

　　　　　若是回归问题，就将均值作为最后结果。

　　方法二：增量模型 （boosting的思想）

　　思路：使用全部的样本作为训练集，得到分类器L1

　　　　　从L1正确分类的样本中和错误分类的样本中各抽取50%的数据，即循环的一边采样一个。此时训练样本是平衡的。训练得到的分类器作为L2.

　　　　　从L1和L2分类结果中，选取结果不一致的样本作为训练集得到分类器L3.

　　　　　最后投票L1,L2,L3结果得到最后的分类结果。

三、将二分类问题转换成其他问题。

　　可以将不平衡的二分类问题转换成异常点检测，或者一分类问题（可使用one-class svm建模）

四、改变正负类别样本在模型中的权重。

　　使用代价函数学习得到每个类的权值，大类的权值小，小类的权值大。刚开始，可以设置每个类别的权值与样本个数比例的倒数，然后可以使用过采样进行调优。

五、注意点：

　　1.不平衡问题的评价指标

　　准确度这个评价指标在类别不均衡的分类任务中并不能work。几个比传统的准确度更有效的评价指标：

　　混淆矩阵(Confusion Matrix)：使用一个表格对分类器所预测的类别与其真实的类别的样本统计，分别为：TP、FN、FP与TN。
　　精确度(Precision)
　　召回率(Recall)
　　F1得分(F1 Score)：精确度与找召回率的加权平均。
  特别是：

　　Kappa (Cohen kappa)
　　ROC曲线(ROC Curves)：见Assessing and Comparing Classifier Performance with ROC Curves

　　2.交叉验证

　　在K-Fold 校验中，每一份数据集中原则上应该保持类别样本比例一样或者近似，如果每份数据集中小类样本数目过少，那么应该降低K的值，知道小类样本的个数足够。



###### 7、sklearn参数
class sklearn.linear_model.LogisticRegression(

penalty=’l2’, 参数类型：str，可选：‘l1’ or ‘l2’, 默认: ‘l2’。该参数用于确定惩罚项的范数

dual=False, 参数类型：bool,默认：False。双重或原始公式。使用liblinear优化器，双重公式仅实现l2惩罚。

tol=0.0001, 参数类型：float，默认：e-4。停止优化的错误率

C=1.0, 参数类型：float，默认；1。正则化强度的导数，值越小强度越大。

fit_intercept=True, 参数类型：bool，默认：True。确定是否在目标函数中加入偏置。

intercept_scaling=1, 参数类型：float，默认：1。仅在使用“liblinear”且self.fit_intercept设置为True时有用。

class_weight=None, 参数类型：dict，默认：None。根据字典为每一类给予权重，默认都是1.

random_state=None, 参数类型：int，默认：None。在打乱数据时，选用的随机种子。

solver=’warn’, 参数类型：str，可选：{‘newton-cg’, ‘lbfgs’, ‘liblinear’, ‘sag’, ‘saga’}, 默认：liblinear。选用的优化器。

max_iter=100, 参数类型：int，默认：100。迭代次数。multi_class=’warn’, 参数类型：str，可选：{‘ovr’, ‘multinomial’, ‘auto’}，默认：ovr。如果选择的选项是'ovr'，

　　那么二进制问题适合每个标签。对于“多项式”，最小化的损失是整个概率分布中的多项式损失拟合，即使数据是二进制的。当solver 　='liblinear'时，'multinomial'不

　　可用。如果数据是二进制的，或者如果solver ='liblinear'，'auto'选择'ovr'，否则选择'multinomial'。

verbose=0, 参数类型：int，默认：0。对于liblinear和lbfgs求解器，将详细设置为任何正数以表示详细程度。

warm_start=False, 参数类型：bool，默认：False。是否使用之前的优化器继续优化。

n_jobs=None，参数类型：bool，默认：None。是否多线程

refer：
https://blog.csdn.net/xiaocong1990/article/details/82145097 
https://blog.csdn.net/lx_ros/article/details/81263209 
